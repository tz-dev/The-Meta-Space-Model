# Script: 10a_plot_z_sky_mean.py
# Description: Visualizes the mean redshift from z_sky_mean.csv as a sky map and checks for isotropy.
# Author: Automatically generated by Grok 3 (xAI)
# Date: 2025-07-05
# Version: 1.0
# Inputs: z_sky_mean.csv (CSV file containing sky-binned redshift data)
# Outputs: img/z_sky_mean_map.png (sky map visualization), results.csv (updated with analysis results),
#          z_sky_isotropy_summary.txt (summary log of isotropy analysis)
# Dependencies: numpy (numerical operations), pandas (data manipulation), matplotlib (plotting),
#               os (file system operations), datetime (timestamp generation), csv (file I/O)
# Purpose: Generates a heatmap visualization of mean redshift across sky regions and performs an isotropy
#          analysis, logging results to CSV and a summary file for further evaluation.

import pandas as pd  # Import Pandas for data manipulation and CSV handling
import numpy as np  # Import NumPy for numerical computations
import matplotlib.pyplot as plt  # Import Matplotlib for plotting
import os  # Import os for file and directory operations
from datetime import datetime  # Import for timestamp generation
import csv  # Import for CSV file operations

def main():
    """
    Main function to load sky-binned data, perform isotropy analysis, and generate a sky map visualization.
    """
    # Load the CSV file containing sky-binned redshift data
    df = pd.read_csv("z_sky_mean.csv")

    # Define the grid based on unique RA and DEC minimum values
    ra_vals = sorted(set(df["ra_min"]))  # Extract and sort unique RA minimum values
    dec_vals = sorted(set(df["dec_min"]))  # Extract and sort unique DEC minimum values
    ra_bins = len(ra_vals)  # Number of RA bins
    dec_bins = len(dec_vals)  # Number of DEC bins

    # Initialize a 2D array with NaN values to store mean redshift data
    z_mean_map = np.full((dec_bins, ra_bins), np.nan)
    for _, row in df.iterrows():  # Iterate over each row in the DataFrame
        i = dec_vals.index(row["dec_min"])  # Get index for DEC value
        j = ra_vals.index(row["ra_min"])  # Get index for RA value
        z_mean_map[i, j] = row["mean_z"]  # Assign mean redshift to corresponding position

    # Perform isotropy analysis on the redshift map
    flat_z = z_mean_map[~np.isnan(z_mean_map)]  # Flatten array, excluding NaN values
    z_min, z_max = np.min(flat_z), np.max(flat_z)  # Calculate minimum and maximum redshift
    z_mean = np.mean(flat_z)  # Calculate mean redshift
    z_std = np.std(flat_z)  # Calculate standard deviation of redshift

    # Print isotropy analysis results
    print(f"Isotropy check:")
    print(f"  z̄ min  = {z_min:.3f}")
    print(f"  z̄ max  = {z_max:.3f}")
    print(f"  z̄ mean = {z_mean:.3f}")
    print(f"  z̄ std  = {z_std:.3f}")

    # Create heatmap visualization
    ra_min = min(ra_vals)  # Minimum RA value for plot extent
    ra_max = max(df["ra_max"])  # Maximum RA value for plot extent
    dec_min = min(dec_vals)  # Minimum DEC value for plot extent
    dec_max = max(df["dec_max"])  # Maximum DEC value for plot extent

    plt.figure(figsize=(12, 6))  # Create a new figure with specified size (12x6 inches)
    cmap = plt.cm.plasma  # Set colormap to plasma
    cmap.set_bad("lightgrey")  # Set color for NaN values to light grey

    im = plt.imshow(
        np.flipud(z_mean_map),  # Flip the map vertically for correct orientation
        extent=[ra_min, ra_max, dec_min, dec_max],  # Set plot extent based on RA and DEC ranges
        aspect='auto',  # Adjust aspect ratio automatically
        cmap=cmap,  # Apply the plasma colormap
        interpolation='none'  # Disable interpolation for pixelated appearance
    )
    plt.colorbar(im, label='Mean Redshift $\\bar{z}$')  # Add colorbar with label
    plt.xlabel('Right Ascension (RA) [°]')  # Set x-axis label
    plt.ylabel('Declination (DEC) [°]')  # Set y-axis label
    plt.title('Mean Redshift by Sky Regions')  # Set plot title
    plt.grid(False)  # Disable grid lines
    plt.tight_layout()  # Adjust layout to prevent label cutoff

    # Create 'img' directory with error handling
    try:
        os.makedirs("img", exist_ok=True)  # Create directory if it doesn't exist
    except Exception as e:  # Handle any errors during directory creation
        print(f"Warning: Could not create 'img' directory: {e}")  # Print warning if failed

    plt.savefig("img/z_sky_mean_map.png")  # Save the plot as a PNG file

    # Update results.csv without duplicates
    results_path = "results.csv"  # Path to the results CSV file
    script_id = "10a_plot_z_sky_mean.py"  # Identifier for this script

    try:
        # Load existing results
        rows = []  # List to hold existing rows
        if os.path.exists(results_path):  # Check if results file exists
            with open(results_path, "r", encoding="utf-8") as f:  # Open file for reading
                reader = csv.reader(f)  # Create CSV reader
                rows = list(reader)  # Read all rows
            header = rows[0]  # Extract header row
            rows = [row for row in rows if row[0] != script_id]  # Filter out existing rows from this script
        else:  # If file doesn't exist
            header = ["script", "parameter", "value", "target", "deviation", "timestamp"]  # Define default header

        # Determine min and max from valid data
        df_valid = df.dropna(subset=["mean_z"])  # Drop rows with NaN in mean_z
        z_min = df_valid["mean_z"].min()  # Calculate minimum valid mean_z
        z_max = df_valid["mean_z"].max()  # Calculate maximum valid mean_z

        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")  # Generate current timestamp
        new_rows = [  # Prepare new rows for CSV
            [script_id, "z_mean_min", z_min, "", "", timestamp],  # Row for minimum redshift
            [script_id, "z_mean_max", z_max, "", "", timestamp],  # Row for maximum redshift
            [script_id, "z_mean_avg", z_mean, "N/A", "N/A", timestamp],  # Row for mean redshift
            [script_id, "z_mean_std", z_std, "ideal ≈ 0 (isotrop)", "N/A", timestamp]  # Row for standard deviation
        ]

        with open(results_path, "w", newline="", encoding="utf-8") as f:  # Open file for writing
            writer = csv.writer(f)  # Create CSV writer
            writer.writerow(header)  # Write header
            writer.writerows(rows + new_rows)  # Write existing and new rows

    except Exception as e:  # Handle any errors during CSV update
        print(f"Error updating results.csv: {e}")  # Print error message

    plt.show()  # Display the plot interactively

    # Write summary log
    with open("z_sky_isotropy_summary.txt", "w", encoding="utf-8") as f:  # Open summary file for writing
        f.write("Isotropy check:\n")  # Write section header
        f.write(f"z̄ min  = {z_min:.6f}\n")  # Write minimum redshift
        f.write(f"z̄ max  = {z_max:.6f}\n")  # Write maximum redshift
        f.write(f"z̄ mean = {z_mean:.6f}\n")  # Write mean redshift
        f.write(f"z̄ std  = {z_std:.6f}\n")  # Write standard deviation

if __name__ == "__main__":  # Entry point when script is run directly
    main()  # Execute the main function